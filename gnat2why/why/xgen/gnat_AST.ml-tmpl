(* This package is automatically generated by xtree. Do not edit manually. *)

type uint = Uint of int
type ureal = Ureal of { numerator : int ; denominator : int; base : int }

(* GNAT *)

type source_ptr = unit
type node_id = unit

type symbol = string
type symbol_set = string list
type string_sets_set = string list

_@Declare_OCaml_Why_Sinfo_Types@_

(* Why.Types *)

type why_node_id = why_node
and why_node_oid = why_node option
and why_node_list = why_node list
and why_node_olist = why_node list option
and why_node_set = why_node list

(* Why.Opaque_ids *)

_@Declare_OCaml_Opaque_Ids@_

_@Declare_OCaml_Why_Node_Type@_

type 'a mode =
  | Expr : expr mode
  | Term : term mode
  | Patt : pattern mode

let rec why_node_to_ptree ~mode why_node = match why_node with
  | W_conditional (_, _, _, _, condition, then_part, else_if_parts, else_part, _) ->
    let rec aux = function
      | [] ->
        (match else_part, mode with
         | Some x, _ -> why_node_to_ptree ~mode x
         | None, Ew_prog -> E.tuple []
         | None, _ -> true_)
      |
    conditional ~mode
      (why_node_to_ptree ~mode condition)
      (why_node_to_ptree ~mode then_part)
      (List.fold_left
         (why_node_to_ptree ~mode else_part))

(* keep this comment *)
